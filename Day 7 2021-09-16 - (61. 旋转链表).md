# 开始刷题

## 题目简介

 
【Day 7 】2021-09-16 - (61. 旋转链表)
-------------------


### 题目思路

+ 记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。
+ 这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k mod n)个节点（从 0 开始计数）。这样，我们可以先将给定的链表连接成环，然后将指定位置断开。
+ 具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n - 1) - (k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。
+ 特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。



## 题目代码
### 代码块
``` c++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(k==0 || head == nullptr ||head->next == nullptr) //链表为0或者链表只有一个数据或者不移动
        {
            return head;
        }
        int n = 1; //长度
        ListNode* iter = head;
        while(iter->next!=nullptr){
            iter = iter->next;
            n++;
        }
        int add = n-k%n;//新链表的最后一个节点
        if(add == n){
            return head;
        }
        iter->next = head;
        while(add--){
            iter = iter->next;
        }
        ListNode* ret = iter->next;
        iter->next = nullptr;
        return ret;
    }
};
```

## 复杂度
+ 空间复杂度 O(1)
+ 时间复杂度 O(n)
